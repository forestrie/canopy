---
# curl examples that excercise the scrapi endpoints

version: "3"

vars:
  BASE_URL: "{{.BASE_URL}}" # wrangler
  #BASE_URL: '{{.BASE_URL | default "http://localhost:5173"}}' # vite
  #BASE_URL: https://canopy-api.robinbryce.workers.dev/logs/3062ea57-c184-41d8-bd61-296b02c680d8
  API_KEY: "test-api-key"

tasks:
  post-entry:
    desc: Post a COSE Sign1 message with random UUID to the /entries endpoint
    cmds:
      - cmd: |
          http_code=$(node scripts/gen-cose-sign1.mjs \
          | curl -v -w "%{http_code}" -X POST "{{.BASE_URL}}/entries" \
          -H 'Content-Type: application/cose; cose-type="cose-sign1"' \
          -H "Authorization: Bearer {{.API_KEY}}" \
          --output post-entry-rand.response \
          --data-binary @-)

          if [ "$http_code" -ge 400 ]; then
            echo ""
            echo "Error response body (decoded):"
            node scripts/decode-problem-details.mjs < post-entry-rand.response
          fi

  resolve-receipt:
    desc: Poll query-registration-status (0.5s) then fetch receipt to resolve-receipt.cbor
    vars:
      # Optional path to a pre-built COSE Sign1 statement. When unset, a random
      # statement is generated with gen-cose-sign1.mjs.
      S: '{{.S | default ""}}'
    cmds:
      - cmd: |
          set -euo pipefail

          # Capture the UTC start time for this run.
          START_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # 1) POST /entries to obtain the registration-status URL (Location header)
          post_headers=$(mktemp)
          post_body=$(mktemp)

          if [ -n "{{.S}}" ]; then
            echo "Using pre-built statement from: {{.S}}"
          fi

          post_code=$(
            {
              if [ -n "{{.S}}" ]; then
                cat "{{.S}}"
              else
                node scripts/gen-cose-sign1.mjs
              fi
            } \
            | curl -sS -D "$post_headers" -w "%{http_code}" -X POST "{{.BASE_URL}}/entries" \
              -H 'Content-Type: application/cose; cose-type="cose-sign1"' \
              -H "Authorization: Bearer {{.API_KEY}}" \
              --output "$post_body" \
              --data-binary @-
          )

          post_location=$(grep -i '^location:' "$post_headers" | awk '{print $2}' | tr -d '\r')

          if [ "$post_code" -ge 400 ]; then
            echo ""
            echo "Error response body (decoded):"
            node scripts/decode-problem-details.mjs < "$post_body"
            exit 1
          fi

          if [ "$post_code" != "303" ] || [ -z "$post_location" ]; then
            echo "Unexpected response from post-entry: http_code=$post_code location=$post_location"
            exit 1
          fi

          status_url="$post_location"
          echo "status_url: $status_url"

          # Log the derived content hash segment so we can cross-check KV keys.
          content_hash="$(printf '%s\n' "$status_url" | awk -F/ '{print $NF}')"
          echo "content_hash: $content_hash"

          # 2) Poll query-registration-status until it redirects to a /receipt URL.
          # Default: 200 attempts with 1s between each, override via MAX_ATTEMPTS.
          max_attempts=${MAX_ATTEMPTS:-200}
          attempt=0
          receipt_url=""

          while [ "$attempt" -lt "$max_attempts" ]; do
            attempt=$((attempt + 1))

            poll_headers=$(mktemp)
            poll_body=$(mktemp)

            poll_code=$(curl -sS -D "$poll_headers" -w "%{http_code}" -X GET "$status_url" \
              -H "Authorization: Bearer {{.API_KEY}}" \
              --output "$poll_body")

            poll_location=$(grep -i '^location:' "$poll_headers" | awk '{print $2}' | tr -d '\r')

            if [ "$poll_code" -ge 400 ]; then
              echo ""
              echo "Error response body (decoded):"
              node scripts/decode-problem-details.mjs < "$poll_body"
              exit 1
            fi

            if [ "$poll_code" != "303" ] || [ -z "$poll_location" ]; then
              echo "Unexpected registration-status response: http_code=$poll_code location=$poll_location"
              exit 1
            fi

            if echo "$poll_location" | grep -q '/receipt$'; then
              receipt_url="$poll_location"
              break
            fi

            sleep 1
          done

          if [ -z "$receipt_url" ]; then

            # When we time out, inspect the KV namespace to understand timing
            # between registration and receipt cache writes.
            LOG_ID=$(printf '%s\n' "$status_url" | awk -F/ '{for (i=1;i<=NF;i++) if ($i=="logs") {print $(i+1); exit}}')

            echo "Inspecting KV entries for log_id=$LOG_ID"

            KV_NS_ID="5dbca58875874fc88653d4c9d66ac760"
            KV_JSON=$(wrangler kv key list --config packages/apps/canopy-api/wrangler.jsonc --namespace-id "$KV_NS_ID" --remote 2>/dev/null || echo "[]")

            # Collect all KV keys for this logId.
            KV_KEYS_FOR_LOG=$(printf '%s\n' "$KV_JSON" | jq -r --arg log "$LOG_ID" '.[] | select(.name | startswith("ranger/v1/" + $log + "/latest/")) | .name' 2>/dev/null || echo "")

            if [ -z "$KV_KEYS_FOR_LOG" ]; then
              echo "No KV entries found for log_id=$LOG_ID in namespace $KV_NS_ID"
              exit 1
            fi

            # For each key, fetch its idtimestamp and build "idtimestamp key" lines,
            # then sort lexically by idtimestamp to find the most recent.
            LAST_LINE=$(printf '%s\n' "$KV_KEYS_FOR_LOG" | while IFS= read -r key; do
              [ -z "$key" ] && continue
              val=$(wrangler kv key get --config packages/apps/canopy-api/wrangler.jsonc --namespace-id "$KV_NS_ID" --remote "$key" 2>/dev/null || echo "")
              idhex=$(printf '%s\n' "$val" | jq -r '.idtimestamp // empty' 2>/dev/null || echo "")
              [ -z "$idhex" ] && continue
              printf '%s %s\n' "$idhex" "$key"
            done | sort | tail -n 1)

            if [ -z "$LAST_LINE" ]; then
              echo "No KV entries with idtimestamp found for log_id=$LOG_ID in namespace $KV_NS_ID"
              exit 1
            fi

            LAST_IDTS_HEX=$(printf '%s\n' "$LAST_LINE" | awk '{print $1}')
            LAST_KEY=$(printf '%s\n' "$LAST_LINE" | cut -d' ' -f2-)

            echo "Last KV entry key: $LAST_KEY"
            echo "Last idtimestamp (hex): $LAST_IDTS_HEX"

            # Use the merklelog:idtimestamp:utc task to convert idtimestamp to a UTC
            # timestamp string. This task currently prints a UTC value like
            # 2025-12-26T11:26:53UTC.
            LAST_IDTS_UTC=$(task -s -t {{.ROOT_TASKFILE}} merklelog:idtimestamp:utc:$LAST_IDTS_HEX 2>/dev/null | tail -n 1 || echo "")

            if [ -z "$LAST_IDTS_UTC" ]; then
              echo "Could not obtain UTC timestamp from merklelog:idtimestamp:utc for $LAST_IDTS_HEX"
              exit 1
            fi

            echo "Timed out waiting for receipt. status_url=$status_url"
            printf 'START_UTC     : %s\n' "$START_UTC"
            printf 'LAST_ENTRY_UTC: %s\n' "$LAST_IDTS_UTC"

            exit 1
          fi

          # 3) GET /receipt and save to resolve-receipt.cbor
          tmp_receipt=$(mktemp)

          receipt_code=$(curl -sS -w "%{http_code}" -X GET "$receipt_url" \
            -H "Authorization: Bearer {{.API_KEY}}" \
            -H 'Accept: application/scitt-receipt+cbor' \
            --output "$tmp_receipt")

          if [ "$receipt_code" -ge 400 ]; then
            echo ""
            echo "Error response body (decoded):"
            node scripts/decode-problem-details.mjs < "$tmp_receipt"
            exit 1
          fi

          mv "$tmp_receipt" resolve-receipt.cbor
          echo "Saved receipt to resolve-receipt.cbor"
