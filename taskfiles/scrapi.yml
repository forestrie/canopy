---
# curl examples that excercise the scrapi endpoints

version: "3"

vars:
  BASE_URL: "{{.BASE_URL}}" # wrangler
  API_KEY: "test-api-key"

tasks:
  create-statement:hello:
    desc: Generate a hello world COSE Sign1 statement
    cmds:
      - node scripts/gen-cose-sign1.mjs

  create-statement:*:
    desc: Generate a COSE Sign1 statement with custom message
    vars:
      MESSAGE: "{{index .MATCH 0}}"
    cmds:
      - node scripts/gen-cose-sign1.mjs "{{.MESSAGE}}"

  decode-receipt:*:
    desc: Decode a CBOR receipt file and display in CDDL notation
    vars:
      RECEIPT: "{{index .MATCH 0}}"
    cmds:
      - node scripts/decode-receipt.mjs "{{.RECEIPT}}"

  register-statement:*:
    desc: Create, register, and resolve a COSE Sign1 statement to receipt
    silent: true
    vars:
      MESSAGE: "{{index .MATCH 0}}"
      MAX_POLLS: '{{.MAX_POLLS | default "30"}}'
      O: '{{.O | default "receipt.cbor"}}'
    cmds:
      - cmd: |
          set -euo pipefail

          # Generate statement
          STATEMENT=$(task -s -t "{{.ROOT_TASKFILE}}" "scrapi:create-statement:{{.MESSAGE}}")

          START_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # POST /entries
          post_headers=$(mktemp)
          post_body=$(mktemp)
          trap 'rm -f "$post_headers" "$post_body"' EXIT

          post_code=$(printf '%s' "$STATEMENT" \
            | curl -sS -D "$post_headers" -w "%{http_code}" -X POST "{{.BASE_URL}}/entries" \
              -H 'Content-Type: application/cose; cose-type="cose-sign1"' \
              -H "Authorization: Bearer {{.API_KEY}}" \
              --output "$post_body" \
              --data-binary @-)

          if [ "$post_code" -ge 400 ]; then
            echo "POST /entries failed with $post_code" >&2
            node scripts/decode-problem-details.mjs < "$post_body" >&2
            exit 1
          fi

          post_location=$(grep -i '^location:' "$post_headers" | awk '{print $2}' | tr -d '\r')

          if [ "$post_code" != "303" ] || [ -z "$post_location" ]; then
            echo "Unexpected POST response: code=$post_code location=$post_location" >&2
            exit 1
          fi

          status_url="$post_location"

          # Poll for receipt
          receipt_url=""
          for attempt in $(seq 1 {{.MAX_POLLS}}); do
            poll_headers=$(mktemp)
            poll_body=$(mktemp)

            poll_code=$(curl -sS -D "$poll_headers" -w "%{http_code}" -X GET "$status_url" \
              -H "Authorization: Bearer {{.API_KEY}}" \
              --output "$poll_body")

            if [ "$poll_code" -ge 400 ]; then
              echo "Poll failed with $poll_code" >&2
              node scripts/decode-problem-details.mjs < "$poll_body" >&2
              rm -f "$poll_headers" "$poll_body"
              exit 1
            fi

            poll_location=$(grep -i '^location:' "$poll_headers" | awk '{print $2}' | tr -d '\r')
            rm -f "$poll_headers" "$poll_body"

            if echo "$poll_location" | grep -q '/receipt$'; then
              receipt_url="$poll_location"
              break
            fi

            sleep 1
          done

          if [ -z "$receipt_url" ]; then
            echo "Timed out after {{.MAX_POLLS}} polls (started $START_UTC)" >&2
            exit 1
          fi

          # GET receipt
          receipt_body=$(mktemp)
          receipt_code=$(curl -sS -w "%{http_code}" -X GET "$receipt_url" \
            -H "Authorization: Bearer {{.API_KEY}}" \
            -H 'Accept: application/scitt-receipt+cbor' \
            --output "$receipt_body")

          if [ "$receipt_code" -ge 400 ]; then
            echo "GET receipt failed with $receipt_code" >&2
            node scripts/decode-problem-details.mjs < "$receipt_body" >&2
            rm -f "$receipt_body"
            exit 1
          fi

          mv "$receipt_body" "{{.O}}"
          echo "$(cd "$(dirname "{{.O}}")" && pwd)/$(basename "{{.O}}")"

  sequence-statement:*:
    desc: Create, register, and wait for sequencing (not full receipt)
    silent: true
    vars:
      MESSAGE: "{{index .MATCH 0}}"
      MAX_POLLS: '{{.MAX_POLLS | default "60"}}'
    cmds:
      - cmd: |
          set -euo pipefail

          # Generate statement
          STATEMENT=$(task -s -t "{{.ROOT_TASKFILE}}" "scrapi:create-statement:{{.MESSAGE}}")

          START_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # POST /entries
          post_headers=$(mktemp)
          post_body=$(mktemp)
          trap 'rm -f "$post_headers" "$post_body"' EXIT

          post_code=$(printf '%s' "$STATEMENT" \
            | curl -sS -D "$post_headers" -w "%{http_code}" -X POST "{{.BASE_URL}}/entries" \
              -H 'Content-Type: application/cose; cose-type="cose-sign1"' \
              -H "Authorization: Bearer {{.API_KEY}}" \
              --output "$post_body" \
              --data-binary @-)

          if [ "$post_code" -ge 400 ]; then
            echo "POST /entries failed with $post_code" >&2
            node scripts/decode-problem-details.mjs < "$post_body" >&2
            exit 1
          fi

          post_location=$(grep -i '^location:' "$post_headers" | awk '{print $2}' | tr -d '\r')

          if [ "$post_code" != "303" ] || [ -z "$post_location" ]; then
            echo "Unexpected POST response: code=$post_code location=$post_location" >&2
            exit 1
          fi

          status_url="$post_location"

          # Poll for sequencing completion (Location header changes to include /receipt)
          for attempt in $(seq 1 {{.MAX_POLLS}}); do
            poll_headers=$(mktemp)
            poll_body=$(mktemp)

            poll_code=$(curl -sS -D "$poll_headers" -w "%{http_code}" -X GET "$status_url" \
              -H "Authorization: Bearer {{.API_KEY}}" \
              --output "$poll_body")

            if [ "$poll_code" -ge 400 ]; then
              echo "Poll failed with $poll_code" >&2
              node scripts/decode-problem-details.mjs < "$poll_body" >&2
              rm -f "$poll_headers" "$poll_body"
              exit 1
            fi

            poll_location=$(grep -i '^location:' "$poll_headers" | awk '{print $2}' | tr -d '\r')
            rm -f "$poll_headers" "$poll_body"

            if echo "$poll_location" | grep -q '/receipt$'; then
              # Sequencing complete - output the receipt URL (don't fetch it)
              echo "$poll_location"
              exit 0
            fi

            sleep 0.25
          done

          echo "Timed out after {{.MAX_POLLS}} polls (started $START_UTC)" >&2
          exit 1

  # ---------------------------------------------------------------------------
  # Smoke test primitives
  #
  # These tasks are composable building blocks for throughput testing.
  # - post-statement: POST one statement, outputs status_url to stdout
  # - poll-status: poll a status URL until sequenced, outputs receipt_url
  # - smoke:N: batch N statements in parallel, report throughput
  #
  # Design: informational output goes to stderr, data output to stdout.
  # This allows composition via pipes and command substitution.
  # ---------------------------------------------------------------------------

  post-statement:
    desc: Generate and POST one statement, output status_url to stdout
    silent: true
    vars:
      MSG: '{{.MSG | default "smoke"}}'
    cmds:
      - cmd: |
          set -euo pipefail
          statement=$(node scripts/gen-cose-sign1.mjs "{{.MSG}}" 2>/dev/null)
          headers=$(mktemp)
          trap 'rm -f "$headers"' EXIT
          code=$(printf '%s' "$statement" | curl -sS -D "$headers" -w "%{http_code}" \
            -X POST "{{.BASE_URL}}/entries" \
            -H 'Content-Type: application/cose; cose-type="cose-sign1"' \
            -H "Authorization: Bearer {{.API_KEY}}" \
            --output /dev/null --data-binary @-)
          if [ "$code" -ge 400 ]; then
            echo "POST failed: $code" >&2
            exit 1
          fi
          grep -i '^location:' "$headers" | awk '{print $2}' | tr -d '\r'

  poll-status:
    desc: Poll a status URL until sequenced, output receipt_url to stdout
    silent: true
    vars:
      STATUS_URL: '{{.STATUS_URL}}'
      MAX_POLLS: '{{.MAX_POLLS | default "120"}}'
    cmds:
      - cmd: |
          set -euo pipefail
          for attempt in $(seq 1 {{.MAX_POLLS}}); do
            headers=$(mktemp)
            curl -sS -D "$headers" -o /dev/null "{{.STATUS_URL}}" \
              -H "Authorization: Bearer {{.API_KEY}}" 2>/dev/null || true
            loc=$(grep -i '^location:' "$headers" | awk '{print $2}' | tr -d '\r')
            rm -f "$headers"
            if echo "$loc" | grep -q '/receipt$'; then
              echo "$loc"
              exit 0
            fi
            sleep 0.25
          done
          echo "timeout" >&2
          exit 1

  smoke:3:
    desc: "Smoke test: 3 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=3
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-3-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:5:
    desc: "Smoke test: 5 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=5
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-5-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:10:
    desc: "Smoke test: 10 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=10
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-10-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:25:
    desc: "Smoke test: 25 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=25
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-25-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:50:
    desc: "Smoke test: 50 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=50
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-50-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:75:
    desc: "Smoke test: 75 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=75
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-75-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:100:
    desc: "Smoke test: 100 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=100
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-100-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:150:
    desc: "Smoke test: 150 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=150
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-150-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:500:
    desc: "Smoke test: 500 statements in parallel, report throughput"
    silent: true
    cmds:
      - cmd: |
          set -euo pipefail
          count=500
          start_ns=$(python3 -c 'import time; print(int(time.time_ns()))')
          tmpdir=$(mktemp -d)
          trap 'rm -rf "$tmpdir"' EXIT

          # Parallel POST phase
          echo "POSTing $count statements..." >&2
          for i in $(seq 1 $count); do
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:post-statement MSG="smoke-500-$i-$start_ns" > "$tmpdir/$i.url" 2>/dev/null &
          done
          wait
          post_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Parallel poll phase
          echo "Polling for sequencing..." >&2
          for i in $(seq 1 $count); do
            url=$(cat "$tmpdir/$i.url")
            task -s -t "{{.ROOT_TASKFILE}}" scrapi:poll-status STATUS_URL="$url" >/dev/null 2>/dev/null &
          done
          wait
          end_ns=$(python3 -c 'import time; print(int(time.time_ns()))')

          # Report
          post_ms=$(( (post_ns - start_ns) / 1000000 ))
          total_ms=$(( (end_ns - start_ns) / 1000000 ))
          throughput=$(echo "scale=1; $count * 1000 / $total_ms" | bc)
          echo "$count statements: POST=${post_ms}ms total=${total_ms}ms (${throughput} stmt/s)"

  smoke:
    desc: "Run all smoke tests (3, 5, 10, 25, 50, 75, 100, 150, 500 statements)"
    cmds:
      - task: smoke:3
      - task: smoke:5
      - task: smoke:10
      - task: smoke:25
      - task: smoke:50
      - task: smoke:75
      - task: smoke:100
      - task: smoke:150
      - task: smoke:500

  post-entry:
    desc: Post a COSE Sign1 message with random UUID to the /entries endpoint
    cmds:
      - cmd: |
          http_code=$(node scripts/gen-cose-sign1.mjs \
          | curl -v -w "%{http_code}" -X POST "{{.BASE_URL}}/entries" \
          -H 'Content-Type: application/cose; cose-type="cose-sign1"' \
          -H "Authorization: Bearer {{.API_KEY}}" \
          --output post-entry-rand.response \
          --data-binary @-)

          if [ "$http_code" -ge 400 ]; then
            echo ""
            echo "Error response body (decoded):"
            node scripts/decode-problem-details.mjs < post-entry-rand.response
          fi
